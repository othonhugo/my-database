# Fase 2: Indexação em Memória (Aceleração de Leituras)

Esta fase foca em transformar a complexidade de leitura de $O(n)$ para $O(1)$.

## Issue 2.1: Implementar `InMemoryIndex`

Criar a estrutura de dados que manterá o mapeamento de `chave -> offset` na RAM, junto com seus testes unitários. Uma implementação não está completa sem seus testes.

- [ ] Criar `storage/index.py` com a interface abstrata `Index`.
- [ ] Implementar `InMemoryIndex` usando um dicionário Python.
- [ ] Implementar os métodos `set(key, offset)`, `get(key)`, e `delete(key)`.

## Issue 2.2: Criar Testes Unitários para o `InMemoryIndex`

Validar formalmente o comportamento do `InMemoryIndex`. Precisamos garantir que ele gerencia corretamente o ciclo de vida dos ponteiros de chave-offset em memória, de forma isolada e sem depender do disco.

- [ ] Configurar os testes unitários para o módulo de índice.
- [ ] Testar o ciclo de vida básico de um registro (definições, atualizações, remoções...).
- [ ] Testar casos de borda para as chaves (ex: chaves vazias, binárias).
- [ ] Testar o comportamento para chaves inexistentes ou previamente deletadas.

## Issue 2.3: Integrar Índice ao Motor de Armazenamento

Modificar `AppendOnlyLogStorage` para usar um `Index` injetado via construtor. O storage irá reconstruir o índice na inicialização, usá-lo para leituras e atualizá-lo em escritas.

- [ ] Alterar `__init__` do `StorageEngine` para aceitar uma instância de `Index`.
- [ ] Implementar `_rebuild_index()`: varre o log existente na inicialização e popula o índice.
- [ ] Atualizar `set()` e `delete()` para atualizar o índice após a escrita no disco.
- [ ] Otimizar `get()` para consultar o índice e usar `file.seek()` para leitura direta, tornando a operação $O(1)$.

## Issue 2.4: Criar Testes de Integração para Storage com Índice

Garantir que a integração entre o `StorageEngine` e o `Index` funciona perfeitamente, especialmente a reconstrução do índice após reinicialização.

- [ ] Atualizar a suíte de testes da Fase 1 para usar a versão com índice.
- [ ] Testar a reconstrução a partir de um log com operações complexas (definições, atualizações, remoções...).
- [ ] Validar que o estado final do banco está correto após uma reinicialização.
